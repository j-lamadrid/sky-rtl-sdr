#include <iostream>
#include <vector>
#include <cmath>
#include <algorithm>
#include <string>

// Include the header file generated by your Python script
#include "model.hpp"

using namespace std;

// --- MATH HELPERS ---

// Calculate Mahalanobis Distance: (x - mu)^T * Precision * (x - mu)
float get_mahalanobis(float snr, float log_dur, float log_rise, int cluster_idx) {
    // 1. Calculate deviation from the mean (d = x - mu)
    float d[3] = {
        snr      - MODEL_MEANS[cluster_idx][0],
        log_dur  - MODEL_MEANS[cluster_idx][1],
        log_rise - MODEL_MEANS[cluster_idx][2]
    };

    // 2. Multiply by Precision Matrix (temp = Precision * d)
    // The precision matrix in the header is flattened (row-major)
    float temp[3] = {0.0f, 0.0f, 0.0f};
    const float* prec = MODEL_PRECS[cluster_idx]; 

    for (int row = 0; row < 3; row++) {
        for (int col = 0; col < 3; col++) {
            // Indexing flattened array: row * 3 + col
            temp[row] += prec[row * 3 + col] * d[col];
        }
    }

    // 3. Dot product (result = d * temp)
    return (d[0] * temp[0]) + (d[1] * temp[1]) + (d[2] * temp[2]);
}

int main() {
    cout << "--- METEOR DETECTOR PC INFERENCE TEST ---" << endl;
    cout << "Loaded Model with " << NUM_CLUSTERS << " clusters." << endl;
    cout << "Enter values to test (Ctrl+C to quit)" << endl;

    while (true) {
        float snr, duration, rise_time;
        
        cout << "\nInput [SNR] [Duration(s)] [RiseTime(s)]: ";
        if (!(cin >> snr >> duration >> rise_time)) break;

        // 1. Feature Transformation (Log Scale)
        // Add epsilon 1e-9 to prevent log(0) errors
        float log_dur = log(duration + 1e-9);
        float log_rise = log(rise_time + 1e-9);

        // 2. Calculate Log-Likelihoods for all clusters
        vector<float> scores(NUM_CLUSTERS);
        float max_score = -1e9; // For numerical stability (Log-Sum-Exp)

        cout << "------------------------------------------------" << endl;
        cout << "Raw Scores (Log-Likelihood):" << endl;

        for (int i = 0; i < NUM_CLUSTERS; i++) {
            float dist = get_mahalanobis(snr, log_dur, log_rise, i);
            
            // GMM Log Probability Formula:
            // -0.5 * (Mahalanobis_Dist + Log_Determinant) + Log_Prior
            // (Note: We ignore the 2*PI constant as it cancels out later)
            scores[i] = -0.5f * (dist + MODEL_LOG_DETS[i]) + MODEL_LOG_PRIORS[i];

            if (scores[i] > max_score) max_score = scores[i];
            
            cout << "  Cluster " << i << ": " << scores[i] << endl;
        }

        // 3. Softmax Normalization (Convert to 0-100% Probability)
        float sum_exps = 0.0f;
        vector<float> probs(NUM_CLUSTERS);

        for (int i = 0; i < NUM_CLUSTERS; i++) {
            probs[i] = exp(scores[i] - max_score); // Subtract max for stability
            sum_exps += probs[i];
        }

        // 4. Print Results
        cout << "------------------------------------------------" << endl;
        cout << "FINAL PROBABILITIES:" << endl;
        
        int best_cluster = -1;
        float best_prob = -1.0f;

        for (int i = 0; i < NUM_CLUSTERS; i++) {
            float percent = (probs[i] / sum_exps) * 100.0f;
            cout << "  Cluster " << i << ": " << percent << "%" << endl;

            if (percent > best_prob) {
                best_prob = percent;
                best_cluster = i;
            }
        }
        
        cout << "------------------------------------------------" << endl;
        cout << "VERDICT: Cluster " << best_cluster << " (" << best_prob << "%)" << endl;
    }

    return 0;
}
